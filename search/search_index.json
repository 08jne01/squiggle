{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"index.html","title":"Squiggle","text":""},{"location":"index.html#introduction","title":"Introduction","text":"<p>Squiggle is vector, matrix and quaternion library. It is heavily inspired by the awesome boost library qvm.</p> <p>Like boost qvm this library allows compatibility with user types via non-intrusive trait specification. This is very useful if you are working with several other libraries each with their own vector type for more see the concepts page.</p> <p>The primary motivation for this additional library was to create a modern vector, matrix and quaternion library which makes use of concepts for faster build times and reduced code complexity.</p> <p>This library is aimed around game-developement and general mathematics. As such only 2,3,4 dimension vectors and square matricies are implemented, along with quaternions.</p>"},{"location":"index.html#other-libraries","title":"Other Libraries","text":"<ul> <li>boost qvm</li> <li>GLM</li> <li>Eigen for heavier linear algebra requirements</li> </ul>"},{"location":"concepts.html","title":"Concepts","text":"<p>The squiggle library was designed to provide general matrix, quaternion and vector operations to any types which satisfy a given set of requirements/concepts.</p> <p>The requirements are non-intrusive requiring no modification to the desired class/struct to use.</p>"},{"location":"concepts.html#traits","title":"Traits","text":"<p>Each compatible struct/class must implement the respective traits so that the intended concepts for the type are satisified.</p> <p>The broad requirements are:     1. number of dimensions     2. accessor functions for components     3. alias for scalar type     4. alias for constructable type of the same concept</p> <p>For requirement 4 this is usually just the type that is being implemented but in the case of a view (holding a reference to another object) it is important that squiggle can construct an appropriate by value, usually when returning from a function by value.</p> <p>For each vector, matrix or quaternion there is a read only concept and a writable concept of these types. Similar to above read only concepts are used for views of other object. If you have a read only object you only need to implement the read accessor functions.</p>"},{"location":"concepts.html#vec_traits","title":"vec_traits","text":"<p>The user vector must specialise the <code>sqg::vec_traits</code> template with their type as shown below.</p> <pre><code>template&lt;typename T&gt;\nstruct Vector3 // example vector\n{\n    T x;\n    T y;\n    T z;\n};\n\n// in namespace sqg\ntemplate&lt;typename T&gt;\nstruct vec_traits&lt;Vector3&lt;T&gt;&gt;\n{\n    using scalar_type = T; // this should match your vector's scalar type\n    using type = Vector3&lt;T&gt;; // value returned by a value operation ie cross(a,b), this must be default constructable.\n    static constexpr int n_dims = 3; // number of dimensions\n\n    // Getters, one for each dimension.\n    // X,Y,Z,W are the expected names for each dimension.\n    static SQUIGGLE_INLINE constexpr scalar_type X(const type&amp; v) { return v.x; }\n    static SQUIGGLE_INLINE constexpr scalar_type Y(const type&amp; v) { return v.y; }\n    static SQUIGGLE_INLINE constexpr scalar_type Z(const type&amp; v) { return v.z; }\n\n    // If your vector/view of a vector is read only then you only need to define\n    // the read/getter functions and it will automatically satisfy the read_vecx_type\n    // where x is the dimension.\n    //\n    // Setters, one for each dimension, you can either provide a function\n    // which returns a scalar_type reference or provide a set function.\n    // Both examples are show here for completeness but only one is needed.\n\n    // scalar reference method\n    static SQUIGGLE_INLINE constexpr scalar_type&amp; X(type&amp; v) { return v.x; }\n    static SQUIGGLE_INLINE constexpr scalar_type&amp; Y(type&amp; v) { return v.y; }\n    static SQUIGGLE_INLINE constexpr scalar_type&amp; Z(type&amp; v) { return v.z; }\n    // setter method\n    static SQUIGGLE_INLINE constexpr void X(type&amp; v, scalar_type s) { v.x = s; }\n    static SQUIGGLE_INLINE constexpr void Y(type&amp; v, scalar_type s) { v.y = s; }\n    static SQUIGGLE_INLINE constexpr void Z(type&amp; v, scalar_type s) { v.z = s; }\n};\n</code></pre> <p>That is everything that is required. Optionally you can provide more trait information to help deduce return types when two vectors are used in a function. The traits <code>vec_value2</code> are used. For example look at the cross function.</p> <pre><code>template&lt;concepts::read_vec3_type V1, concepts::read_vec3_type V2&gt;\nSQUIGGLE_INLINE constexpr vec_value2&lt;V1,V2&gt; cross( const V1&amp; a, const V2&amp; b );\n</code></pre> <p>The user can specialise <code>deduce_vec_traits</code> to prefer one vector over another. Whenever a scalar or value type is chosen between two vectors the <code>deduce_vec_traits</code> is used. The order of operands in the function determines the order in the templates. By default the traits of the left type are used.</p> <pre><code>template&lt;typename T&gt;\nstruct Vector3;\n\ntemplate&lt;typename T, typename V&gt;\nstruct deduce_vec_traits&lt;V, Vector3&lt;T&gt;&gt; { using traits = vec_traits&lt;Vector3&lt;T&gt;&gt;; };\n</code></pre>"},{"location":"concepts.html#mat_traits","title":"mat_traits","text":"<p>The user vector must specialise the <code>sqg::vec_traits</code> template with their type as shown below.</p> <pre><code>template&lt;typename T&gt;\nstruct Matrix33 // example matrix\n{\n    T a[3][3];\n};\n\n// in namespace sqg\ntemplate&lt;typename T&gt;\nstruct mat_traits&lt;Matrix33&lt;T&gt;&gt;\n{\n    using scalar_type = T; // this should match your vector's scalar type\n    using type = Matrix33&lt;T&gt;; // value returned by a value operation ie cross(a,b), this must be default constructable.\n    static constexpr int n_dims = 3; // number of dimensions\n\n    // Getter templated by row and col.\n    template&lt;int row, int col&gt;\n    static SQUIGGLE_INLINE constexpr scalar_type A(const type&amp; v) { return v.a[row][col]; }\n\n    // If your matrix/view of a matrix is read only then you only need to define\n    // the read/getter functions and it will automatically satisfy the read_matxx_type\n    // where x is the dimension.\n    //\n    // Setter templated by row and col, you can either provide a function\n    // which returns a scalar_type reference or provide a set function.\n    // Both examples are show here for completeness but only one is needed.\n\n    // scalar reference method\n    template&lt;int row, int col&gt;\n    static SQUIGGLE_INLINE constexpr scalar_type&amp; Z(type&amp; v) { return v.a[row][col]; }\n    // setter method\n    template&lt;int row, int col&gt;\n    static SQUIGGLE_INLINE constexpr void A(type&amp; v, scalar_type s) { v.a[row][col] = s; }\n};\n</code></pre> <p>That is everything that is required. Optionally you can provide more trait information to help deduce return types when two vectors are used in a function. The traits <code>mat_value2</code> are used.</p> <p>The user can specialise <code>deduce_mat_traits</code> to prefer one matrix over another. Whenever a scalar or value type is chosen between two matrix the <code>deduce_mat_traits</code> is used. The order of operands in the function determines the order in the templates. By default the traits of the left type are used.</p> <pre><code>template&lt;typename T&gt;\nstruct Matrix3;\n\ntemplate&lt;typename T, typename V&gt;\nstruct deduce_mat_traits&lt;V, Matrix3&lt;T&gt;&gt; { using traits = mat_traits&lt;Matrix3&lt;T&gt;&gt;; };\n</code></pre>"},{"location":"concepts.html#concepts_1","title":"Concepts","text":"<p>The squiggle library defines several concepts located in the sqg_concepts.h. These concepts are used for to constrain library functions to the correct types.</p> <pre><code>template&lt;concepts::read_mat22_type M1, concepts::read_mat22_type M2&gt;\nSQUIGGLE_INLINE constexpr mat_value2&lt;M1,M2&gt; operator*( const M1&amp; a, const M2&amp; b )\n</code></pre> <p>For example several * operator functions will exist but for this particular operation we only want to select read only mat22.</p> <p>See below the core concepts.</p> <pre><code>// Vector Dimensions\n// X - 0\n// Y - 1\n// Z - 2\n// W - 3\n// Note this only refers to which setters/getters exist in each\n// dimension not the actual memory layout of the vector that is up\n// to the user. For example the sqg::quat is arranged w,x,y,z;\n//\n// Matrix dimensions are defined by row,col in the template.\n\n// constraint defining getter\nconcept vec_x_read;\nconcept vec_y_read;\nconcept vec_z_read;\nconcept vec_w_read;\nconcept mat_read&lt;row,col&gt;;\n\n// constraint defining setter\nconcept vec_x_write;\nconcept vec_y_write;\nconcept vec_z_write;\nconcept vec_w_write;\nconcept mat_write&lt;row,col&gt;;\n\n// constraint defining setter through getting reference\nconcept vec_x_write_ref;\nconcept vec_y_write_ref;\nconcept vec_z_write_ref;\nconcept vec_w_write_ref;\nconcept mat_write_ref&lt;row,col&gt;;\n</code></pre> <pre><code>// read/write vectors of a given dimension.\nconcept vec2_type;\nconcept vec3_type;\nconcept vec4_type;\n\n// read only vectors of a given dimension.\n// these are primarily used for const views of vectors\n// like the row of matrix.\nconcept read_vec2_type;\nconcept read_vec3_type;\nconcept read_vec4_type;\n\n// read/write matrices of given dimensions.\nconcept mat22_type;\nconcept mat33_type;\nconcept mat44_type;\n\n// read only matricies of given dimensions.\n// these are primarily used for const views of matricies\n// like the transpose of a matrix.\nconcept read_mat22_type;\nconcept read_mat33_type;\nconcept read_mat44_type;\n</code></pre> <p>Any user type can be easily made into a compatible type by providing the corresponding traits.</p>"},{"location":"matrix.html","title":"Matrix","text":"<p>This file lists all the common matrix functions, the syntax is close to C++ but is partly pseudocode to help readbility.</p> <p>read_mat_type is any type that satisfies one of the following concepts.</p> <pre><code>template&lt;typename Scalar&gt; concept read_mat22_type;\ntemplate&lt;typename Scalar&gt; concept read_mat33_type;\ntemplate&lt;typename Scalar&gt; concept read_mat44_type;\n</code></pre> <p>mat_type is any type that satisfies one of the following concepts.</p> <pre><code>template&lt;typename Scalar&gt; concept mat22_type;\ntemplate&lt;typename Scalar&gt; concept mat33_type;\ntemplate&lt;typename Scalar&gt; concept mat44_type;\n</code></pre> <p>Note that for all functions which take two arguments it is implied the number of dimensions of each matrix are the same.</p> <p>There are some type aliases which indicate return types of compatible template parameters. They are listed below.</p> Alias Input Type <code>mat_value</code> <code>matrix</code> or <code>read_matrix</code> constructible matrix type value for this matrix/view <code>mat_scalar</code> <code>matrix</code> or <code>read_matrix</code> scalar type for this matrix/view <code>mat_value2</code> two of <code>matrix</code> or <code>read_matrix</code> chosen constructible matrix type value <code>mat_scalar2</code> two of <code>matrix</code> or <code>read_matrix</code> chosen scalar type"},{"location":"matrix.html#assign","title":"assign","text":"<pre><code>void assign( mat_type&amp; destination, const read_mat_type&amp; source );\n</code></pre> <p>sets destination equal to source</p> <p>requires <code>mat_scalar&lt;a&gt; == mat_scalar&lt;b&gt;</code></p>"},{"location":"matrix.html#set_zero","title":"set_zero","text":"<pre><code>void set_zero( mat_type&amp; matrix );\n</code></pre> <p>zeros all components of matrix</p>"},{"location":"matrix.html#set_identity","title":"set_identity","text":"<pre><code>void set_identity( mat_type&amp; matrix );\n</code></pre> <p>sets matrix to identity matrix of it's dimensions</p>"},{"location":"matrix.html#identity_mat","title":"identity_mat","text":"<pre><code>template&lt;typename Scalar, int dims&gt; \nmat_type&lt;Scalar,dims&gt; identity_mat();\n</code></pre> <p>returns the corresponding squiggle matrix type with scalar type <code>Scalar</code> and number of dimensions specified. For example with <code>dims == 3</code>, mat33 is returned.</p>"},{"location":"matrix.html#transpose","title":"transpose","text":"<pre><code>void transpose( mat_type&amp; matrix );\n</code></pre> <p>in-place transpose of matrix</p>"},{"location":"matrix.html#transposed","title":"transposed","text":"<pre><code>transpose_view&lt;mat_type&gt; transposed( const mat_type&amp; matrix );\n</code></pre> <p>returns <code>transpose_view</code> (contains const matrix reference) of the matrix since this is a shallow copy it cannot be a value on its own but it satisfies <code>read_mat_type</code> so can be used in any function with that requirement. This also means it can be implicitly copied to one of the squiggle matrices. It can be explicitly copied to a user defined matrix using the convert_to function.</p>"},{"location":"matrix.html#determinant","title":"determinant","text":"<pre><code>mat_scalar determinant( const read_mat_type&amp; matrix );\n</code></pre> <p>returns determinant of matrix</p> <p>This is only defined for 2 and 3 dimensional matrices.</p>"},{"location":"matrix.html#row","title":"row","text":"<pre><code>template&lt;int row&gt;\nrow_view&lt;mat_type&gt; row( mat_type&amp; matrix );\n</code></pre> <p>return <code>row_view</code> (contains matrix reference) which satisifies <code>vec_type</code></p> <pre><code>template&lt;int row&gt;\nread_row_view&lt;mat_type&gt; row( const mat_type&amp; matrix );\n</code></pre> <p>return <code>read_row_view</code> (contains matrix reference) which satisfies <code>read_vec_type</code></p> <p>These views cannot be values on their own but they satisfy <code>vec_type</code> and <code>read_vec_type</code> respectively so can be used in any function with that requirement. This also means they can be implicitly copied to one of the squiggle vectors. They can be explicitly copied to a user defined vector using the convert_to function.</p>"},{"location":"matrix.html#col","title":"col","text":"<pre><code>template&lt;int col&gt;\nrow_view&lt;mat_type&gt; col( mat_type&amp; matrix );\n</code></pre> <p>return <code>row_view</code> (contains matrix reference) which satisifies <code>vec_type</code></p> <pre><code>template&lt;int col&gt;\nread_row_view&lt;mat_type&gt; col( const mat_type&amp; matrix );\n</code></pre> <p>return <code>read_row_view</code> (contains matrix reference) which satisfies <code>read_vec_type</code></p> <p>Otherwise the same as row.</p>"},{"location":"matrix.html#set_rot2","title":"set_rot2","text":"<pre><code>void set_rot2( mat22_type&amp; matrix, mat_scalar scalar );\n</code></pre> <p>sets <code>matrix</code> as 2d rotation by angle <code>scalar</code></p> <p>mat_scalar is deduced from matrix</p>"},{"location":"matrix.html#rot2_mat","title":"rot2_mat","text":"<pre><code>mat22&lt;scalar_type&gt; rot2_mat( scalar_type scalar );\n</code></pre> <p>returns 2d rotation by angle <code>scalar</code></p>"},{"location":"matrix.html#operator-unary","title":"operator- unary","text":"<pre><code>mat_value operator-( const read_mat_type&amp; matrix );\n</code></pre> <p>returns componentwise negated matrix</p>"},{"location":"matrix.html#set_rotx","title":"set_rotx","text":"<pre><code>void set_rotx( mat33_type&amp; matrix, mat_scalar scalar );\n</code></pre> <p>sets <code>matrix</code> as rotation by angle <code>scalar</code> about x axis (0 column)</p>"},{"location":"matrix.html#set_roty","title":"set_roty","text":"<pre><code>void set_roty( mat33_type&amp; matrix, mat_scalar scalar );\n</code></pre> <p>sets <code>matrix</code> as rotation by angle <code>scalar</code> about y axis (1 column)</p>"},{"location":"matrix.html#set_rotz","title":"set_rotz","text":"<pre><code>void set_rotz( mat33_type&amp; matrix, mat_scalar scalar );\n</code></pre> <p>sets <code>matrix</code> as rotation by angle <code>scalar</code> about z axis (2 column)</p>"},{"location":"matrix.html#set_rot","title":"set_rot","text":"<pre><code>void set_rot( mat33_type&amp; matrix, const read_vec3_type&amp; axis, mat_scalar scalar );\n</code></pre> <p>sets <code>matrix</code> as rotation by angle <code>scalar</code> about <code>axis</code></p> <p>axis is not normalised by function</p>"},{"location":"matrix.html#rotx_mat","title":"rotx_mat","text":"<pre><code>mat33&lt;scalar_type&gt; rotx_mat( scalar_type scalar );\n</code></pre> <p>returns <code>matrix</code> as rotation by angle <code>scalar</code> about x axis (0 column)</p>"},{"location":"matrix.html#roty_mat","title":"roty_mat","text":"<pre><code>mat33&lt;scalar_type&gt; roty_mat( scalar_type scalar );\n</code></pre> <p>returns <code>matrix</code> as rotation by angle <code>scalar</code> about y axis (1 column)</p>"},{"location":"matrix.html#rotz_mat","title":"rotz_mat","text":"<pre><code>mat33&lt;scalar_type&gt; set_rotz( scalar_type scalar );\n</code></pre> <p>returns <code>matrix</code> as rotation by angle <code>scalar</code> about z axis (2 column)</p>"},{"location":"matrix.html#rot_mat","title":"rot_mat","text":"<pre><code>mat33&lt;vec_scalar&gt; rot_mat( const read_vec3_type&amp; axis, vec_scalar scalar );\n</code></pre> <p>returns <code>matrix</code> as rotation by angle <code>scalar</code> about <code>axis</code></p> <p>axis is not normalised by function, vec_scalar is deduced from axis</p>"},{"location":"matrix.html#operator","title":"operator+","text":"<pre><code>mat_value2 operator+( const read_mat_type&amp; a, const read_mat_type&amp; b );\n</code></pre> <p>returns componentwise sum of matrices</p> <p>requires <code>mat_scalar&lt;a&gt; == mat_scalar&lt;b&gt;</code></p>"},{"location":"matrix.html#operator-","title":"operator-","text":"<pre><code>mat_value2 operator-( const read_mat_type&amp; a, const read_mat_type&amp; b );\n</code></pre> <p>returns componentwise subtraction of matrices</p> <p>requires <code>mat_scalar&lt;a&gt; == mat_scalar&lt;b&gt;</code></p>"},{"location":"matrix.html#operator_1","title":"operator*","text":"<pre><code>mat_value2 operator*( const read_mat_type&amp; a, const read_mat_type&amp; b );\n</code></pre> <p>returns the matrix multiplication ab</p> <p>requires <code>mat_scalar&lt;a&gt; == mat_scalar&lt;b&gt;</code></p>"},{"location":"matrix.html#operator_2","title":"operator/","text":"<pre><code>mat_scalar operator*( const read_mat_type&amp; matrix, mat_scalar scalar );\n</code></pre> <p>returns componentwise divide of matrix by scalar</p> <p>mat_scalar is deduced from matrix</p>"},{"location":"matrix.html#operator-and-operator","title":"operator== and operator!=","text":"<pre><code>bool operator==( const read_mat_type&amp; a, const read_mat_type&amp; b );\n</code></pre> <p>returns componentwise comparison, <code>a == b</code> for operator== and <code>a != b</code> for operator !=</p> <p>requires <code>mat_scalar&lt;a&gt; == mat_scalar&lt;b&gt;</code></p>"},{"location":"quaternion.html","title":"Quaternion","text":"<p>This file lists all the common quaternion functions, the syntax is close to C++ but is partly pseudocode to help readbility.</p> <p>quaternions are types which satisfy any of the following concepts.</p> <pre><code>template&lt;typename Scalar&gt; concept read_quat_type;\ntemplate&lt;typename Scalar&gt; concept quat_type;\n</code></pre> <p>Quaternions and 4 dimensional vectors are the same the only additional constraint quaternions have is that their scalar must be floating point. These means that in addition to the functions below any quat can use the functions compatible with 4 dimensional vectors.</p> <p>Squiggle already defines a 4 dimensional vector but it also defines a quat, the reason is to have the order of the elements match convention, w,x,y,z and to default initialise the quaternion to the identity quaternion. Where instead vec4 is zero initialised.</p> <p>There are some type aliases which indicate return types of compatible template parameters. Since quaternion is the same concept as a vec4 the aliases are the same as seen below.</p> Alias Input Type <code>vec_value</code> <code>vector</code> or <code>read_vector</code> constructible vector type value for this vector/view <code>vec_scalar</code> <code>vector</code> or <code>read_vector</code> scalar type for this vector/view <code>vec_value2</code> two of <code>vector</code> or <code>read_vector</code> chosen constructible vector type value <code>vec_scalar2</code> two of <code>vector</code> or <code>read_vector</code> chosen scalar type"},{"location":"quaternion.html#set_identity","title":"set_identity","text":"<pre><code>void set_identity( quat_type&amp; quaternion );\n</code></pre> <p>sets <code>quaternion</code> to identity quaternion</p>"},{"location":"quaternion.html#identity_quat","title":"identity_quat","text":"<pre><code>template&lt;typename Scalar&gt; \nquat&lt;Scalar&gt; identity_quat();\n</code></pre> <p>returns the corresponding squiggle quat type with scalar type <code>Scalar</code></p>"},{"location":"quaternion.html#vector_component","title":"vector_component","text":"<pre><code>void vector_component( vec3_type&amp; vector, const read_quat_type&amp; quaternion );\n</code></pre> <p>sets <code>vector</code> to vector component (x,y,z) of <code>quaternion</code></p> <pre><code>vec3&lt;vec_scalar&gt; vector_component( const read_quat_type&amp; quaternion );\n</code></pre> <p>returns <code>vec3</code> from vector component (x,y,z) of <code>quaternion</code></p>"},{"location":"quaternion.html#conjugate","title":"conjugate","text":"<pre><code>vec_value conjugate( const read_quat_type&amp; quaternion );\n</code></pre> <p>returns conjugate (Q*) of <code>quaternion</code></p>"},{"location":"quaternion.html#inverse","title":"inverse","text":"<pre><code>vec_value inverse( const read_quat_type&amp; quaternion );\n</code></pre> <p>returns inverse (Q*/|Q|^2) of <code>quaternion</code></p> <p>if quaternion is pure rotation then inverse(q) == conjucate(q), consider using conjugate in these cases for performance.</p>"},{"location":"quaternion.html#operator","title":"operator*","text":"<pre><code>vec_value2 operator*( const read_quat_type&amp; q0, const read_quat_type&amp; q1 )\n</code></pre> <p>returns result of <code>q0q1</code> (quaternion multiplication)</p> <pre><code>vec_value operator*( const read_quat_type&amp; quaternion, const read_vec_type&amp; vector )\n</code></pre> <p>returns result of <code>qvq*</code> (rotate vector by quaternion, sandwich product)</p>"},{"location":"quaternion.html#set_rotx","title":"set_rotx","text":"<pre><code>void set_rotx( quat_type&amp; quaternion, vec_scalar scalar );\n</code></pre> <p>sets <code>quaternion</code> as rotation by angle <code>scalar</code> about x axis</p>"},{"location":"quaternion.html#set_roty","title":"set_roty","text":"<pre><code>void set_roty( quat_type&amp; quaternion, vec_scalar scalar );\n</code></pre> <p>sets <code>quaternion</code> as rotation by angle <code>scalar</code> about y axis</p>"},{"location":"quaternion.html#set_rotz","title":"set_rotz","text":"<pre><code>void set_rotz( quat_type&amp; quaternion, vec_scalar scalar );\n</code></pre> <p>sets <code>quaternion</code> as rotation by angle <code>scalar</code> about z axis</p>"},{"location":"quaternion.html#set_rot","title":"set_rot","text":"<pre><code>void set_rot( quat_type&amp; quaternion, const read_vec3_type&amp; axis, vec_scalar scalar );\n</code></pre> <p>sets <code>quaternion</code> as rotation by angle <code>scalar</code> about <code>axis</code></p> <p>axis is not normalised by function</p>"},{"location":"quaternion.html#rotx_mat","title":"rotx_mat","text":"<pre><code>quat&lt;scalar_type&gt; rotx_mat( scalar_type scalar );\n</code></pre> <p>returns <code>quaternion</code> as rotation by angle <code>scalar</code> about x axis</p>"},{"location":"quaternion.html#roty_mat","title":"roty_mat","text":"<pre><code>quat&lt;scalar_type&gt; roty_mat( scalar_type scalar );\n</code></pre> <p>returns <code>quaternion</code> as rotation by angle <code>scalar</code> about y axis</p>"},{"location":"quaternion.html#rotz_mat","title":"rotz_mat","text":"<pre><code>quat&lt;scalar_type&gt; set_rotz( scalar_type scalar );\n</code></pre> <p>returns <code>quaternion</code> as rotation by angle <code>scalar</code> about z axis</p>"},{"location":"quaternion.html#rot_mat","title":"rot_mat","text":"<pre><code>quat&lt;vec_scalar&gt; rot_mat( const read_vec3_type&amp; axis, vec_scalar scalar );\n</code></pre> <p>returns <code>quaternion</code> as rotation by angle <code>scalar</code> about <code>axis</code></p> <p>axis is not normalised by function, vec_scalar is deduced from axis</p>"},{"location":"types.html","title":"Types","text":""},{"location":"types.html#vector","title":"Vector","text":"<pre><code>template&lt;typename Scalar&gt; vec2;\ntemplate&lt;typename Scalar&gt; vec3;\ntemplate&lt;typename Scalar&gt; vec4;\n</code></pre> <p>Each are accessible with x,y,z,w (up to the number of dimensions). These vectors are special because they contain the conversion operator, this allows them to implicitly be converted to any type to which they can be assigned.</p> <p>Default initialisation is zero.</p>"},{"location":"types.html#matrix","title":"Matrix","text":"<pre><code>template&lt;typename Scalar&gt; mat22;\ntemplate&lt;typename Scalar&gt; mat33;\ntemplate&lt;typename Scalar&gt; mat44;\n</code></pre> <p>The member a is a simple n x n array of Scalar type. These matricies are special because they contain the conversion operator, this allows them to implicitly be converted to any type to which they can be assigned.</p> <p>Default initialisation is zero.</p>"},{"location":"types.html#quaternion","title":"Quaternion","text":"<pre><code>template&lt;std::floating_point Scalar&gt; quat;\n</code></pre> <p>Components are accessible with w,x,y,z (up to the number of dimensions). This quaternion is special because it contains the conversion operator, this allows it to implicitly be converted to any type to which it can be assigned.</p> <p>The <code>quat</code> just implements the <code>vec_traits</code> for a 4 dimension vector. Any 4 dimension vector can be used as a quaternion however this structure is specifically arranged so that the real component (w) is at the start similar to layouts of other quaternions.</p> <p>Furthermore the default initialisation is the identity quaternion.</p>"},{"location":"vector.html","title":"Vector","text":"<p>This file lists all the common vector functions, the syntax is close to C++ but is partly pseudocode to help readbility.</p> <p>read_vec_type is any type that satisfies one of the following concepts.</p> <pre><code>template&lt;typename Scalar&gt; concept read_vec2_type;\ntemplate&lt;typename Scalar&gt; concept read_vec3_type;\ntemplate&lt;typename Scalar&gt; concept read_vec4_type;\n</code></pre> <p>vec_type is any type that satisfies one of the following concepts.</p> <pre><code>template&lt;typename Scalar&gt; concept vec2_type;\ntemplate&lt;typename Scalar&gt; concept vec3_type;\ntemplate&lt;typename Scalar&gt; concept vec4_type;\n</code></pre> <p>Note that for all functions which take two arguments it is implied the number of dimensions of each vector are the same.</p> <p>There are some type aliases which indicate return types of compatible template parameters. They are listed below.</p> Alias Input Type <code>vec_value</code> <code>vector</code> or <code>read_vector</code> constructible vector type value for this vector/view <code>vec_scalar</code> <code>vector</code> or <code>read_vector</code> scalar type for this vector/view <code>vec_value2</code> two of <code>vector</code> or <code>read_vector</code> chosen constructible vector type value <code>vec_scalar2</code> two of <code>vector</code> or <code>read_vector</code> chosen scalar type"},{"location":"vector.html#assign","title":"assign","text":"<pre><code>void assign( vec_type&amp; destination, const read_vec_type&amp; source );\n</code></pre> <p>sets destination equal to source</p> <p>requires <code>vec_scalar&lt;a&gt; == vec_scalar&lt;b&gt;</code></p>"},{"location":"vector.html#set_zero","title":"set_zero","text":"<pre><code>void set_zero( vec_type&amp; vector );\n</code></pre> <p>zeros all components of vector</p>"},{"location":"vector.html#cross","title":"cross","text":""},{"location":"vector.html#2-dimensions","title":"2 dimensions","text":"<pre><code>vec_scalar2 cross( const read_vec2_type&amp; a, const read_vec2_type&amp; b );\n</code></pre> <p>returns cross product (scalar) of 2d vectors</p> <p>requires <code>vec_scalar&lt;a&gt; == vec_scalar&lt;b&gt;</code></p>"},{"location":"vector.html#3-dimensions","title":"3 dimensions","text":"<pre><code>vec_value2 cross( const read_vec3_type&amp; a, const read_vec3_type&amp; b );\n</code></pre> <p>returns cross product (vector) of 3d vectors</p> <p>requires <code>vec_scalar&lt;a&gt; == vec_scalar&lt;b&gt;</code></p>"},{"location":"vector.html#dot","title":"dot","text":"<pre><code>vec_scalar2 dot( const read_vec_type&amp; a, const read_vec_type&amp; b );\n</code></pre> <p>returns dot product of two vectors</p> <p>requires <code>vec_scalar&lt;a&gt; == vec_scalar&lt;b&gt;</code></p>"},{"location":"vector.html#operator-unary","title":"operator- unary","text":"<pre><code>vec_value operator-( const read_vec_type&amp; vector );\n</code></pre> <p>returns componentwise negated vector</p>"},{"location":"vector.html#operator","title":"operator+","text":"<pre><code>vec_value2 operator+( const read_vec_type&amp; a, const read_vec_type&amp; b );\n</code></pre> <p>returns componentwise sum of vectors</p> <p>requires <code>vec_scalar&lt;a&gt; == vec_scalar&lt;b&gt;</code></p>"},{"location":"vector.html#operator-","title":"operator-","text":"<pre><code>vec_value2 operator-( const read_vec_type&amp; a, const read_vec_type&amp; b );\n</code></pre> <p>returns componentwise subtraction of vectors</p> <p>requires <code>vec_scalar&lt;a&gt; == vec_scalar&lt;b&gt;</code></p>"},{"location":"vector.html#operator_1","title":"operator*","text":"<pre><code>vec_scalar operator*( const read_vec_type&amp; vector, vec_scalar scalar );\n</code></pre> <p>or</p> <pre><code>vec_scalar operator*( vec_scalar scalar, const read_vec_type&amp; vector );\n</code></pre> <p>returns componentwise multiplication of vector by scalar</p> <p>vec_scalar is deduced from vector</p>"},{"location":"vector.html#operator_2","title":"operator/","text":"<pre><code>vec_scalar operator*( const read_vec_type&amp; vector, vec_scalar scalar );\n</code></pre> <p>returns componentwise divide of vector by scalar</p> <p>vec_scalar is deduced from vector</p>"},{"location":"vector.html#operator-and-operator","title":"operator== and operator!=","text":"<pre><code>bool operator==( const read_vec_type&amp; a, const read_vec_type&amp; b );\n</code></pre> <p>returns componentwise comparison, <code>a == b</code> for operator== and <code>a != b</code> for operator !=</p> <p>requires <code>vec_scalar&lt;a&gt; == vec_scalar&lt;b&gt;</code></p>"}]}